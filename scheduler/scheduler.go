package scheduler

import (
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/gogo/protobuf/proto"
	mesos "github.com/mesos/go-proto/mesos/v1"
	sched "github.com/mesos/go-proto/mesos/v1/scheduler"
	"github.com/pwzgorilla/libmesos/detector"
	log "github.com/sirupsen/logrus"
)

var ErrDisconnected = errors.New("driver disconnected")

type DriverConfig struct {
	Scheduler Scheduler
	Framework *mesos.FrameworkInfo
	Master    string
}

type MesosSchedulerDriver struct {
	sync.RWMutex

	framework *mesos.FrameworkInfo
	scheduler Scheduler
	handlers  map[sched.Event_Type]func(*sched.Event)
	detector  detector.Detector
	session   *session
	connected bool
	started   chan struct{}
	stopped   chan struct{}
}

func NewMesosSchedulerDriver(config DriverConfig) (*MesosSchedulerDriver, error) {
	driver := &MesosSchedulerDriver{
		framework: config.Framework,
		started:   make(chan struct{}),
		stopped:   make(chan struct{}),
		handlers:  make(map[sched.Event_Type]func(*sched.Event)),
	}

	driver.scheduler = config.Scheduler

	driver.init()

	detector, err := detector.NewDetector(config.Master)
	if err != nil {
		return nil, err
	}

	driver.detector = detector

	return driver, nil
}

func (driver *MesosSchedulerDriver) init() {
	driver.handlers[sched.Event_SUBSCRIBED] = driver.frameworkRegistered
	driver.handlers[sched.Event_OFFERS] = driver.resourcesOffered
	driver.handlers[sched.Event_RESCIND] = driver.resourceOfferRescinded
	driver.handlers[sched.Event_UPDATE] = driver.statusUpdated
	//driver.handlers[sched.Event_HEARTBEAT] = driver.heartBeat
	//driver.handlers[sched.Event_ERROR] = driver.frameworkErrorRcvd
	//driver.handlers[sched.Event_FAILURE] = driver.frameworkFailure
	//driver.handlers[sched.Event_MESSAGE] = driver.frameworkMessageRcvd
}

func (driver *MesosSchedulerDriver) frameworkRegistered(event *sched.Event) {
	log.Println("Handling scheduler driver framework registered event.")

	subscribed := event.GetSubscribed()
	masterInfo := subscribed.GetMasterInfo()
	frameworkId := subscribed.GetFrameworkId()

	log.Infof("Framework registered with ID=%s\n", frameworkId.GetValue())

	driver.framework.Id = frameworkId // generated by master.
	driver.connected = true

	driver.scheduler.Registered(driver, frameworkId, masterInfo)
}

func (driver *MesosSchedulerDriver) resourcesOffered(event *sched.Event) {
	log.Println("Handling resource offers.")

	if !driver.connected {
		log.Infoln("Ignoring ResourceOffersMessage, the driver is not connected!")
		return
	}

	offered := event.GetOffers()

	driver.scheduler.ResourceOffers(driver, offered.GetOffers())
}

func (driver *MesosSchedulerDriver) resourceOfferRescinded(event *sched.Event) {
	log.Println("Handling resource offer rescinded.")

	if !driver.connected {
		log.Infoln("Ignoring ResourceOffersMessage, the driver is not connected!")
		return
	}

	rescind := event.GetRescind()

	log.Println("Rescinding offer ", rescind.OfferId.GetValue())

	driver.scheduler.OfferRescinded(driver, rescind.OfferId)
}

func (driver *MesosSchedulerDriver) statusUpdated(event *sched.Event) {
	if !driver.connected {
		log.Println("Ignoring StatusUpdate message, the driver is not connected!")
		return
	}

	updated := event.GetUpdate()

	status := updated.GetStatus()

	driver.scheduler.StatusUpdate(driver, status)
}

func (driver *MesosSchedulerDriver) heartbeatReceived(event *sched.Event) {
	if !driver.connected {
		log.Println("Ignoring HeartBeat message, the driver is not connected!")
		return
	}

	driver.scheduler.HeartBeated()
}

// Starts the scheduler driver.
// Returns immediately if an error occurs within start sequence.
func (driver *MesosSchedulerDriver) Start() error {
	return driver.start()
}

func (driver *MesosSchedulerDriver) Stop() {
	log.Println("Stop the scheduler driver")

	close(driver.stopped)
}

func (driver *MesosSchedulerDriver) start() error {
	select {
	case <-driver.started:
		return errors.New("Unable to Start: driver has already been started once.")
	default: // proceed
	}

	log.Println("Starting the scheduler driver...")

	if driver.connected {
		return errors.New("driver has already connected")
	}

	session := newSession(driver, driver.detector)
	driver.session = session
	defer session.close()

	for {
		select {
		case event := <-session.events:
			handler, ok := driver.handlers[event.GetType()]
			if !ok {
				continue
			}

			handler(event)
		case err := <-session.errs:
			if err != nil {
				log.Errorln("Scheduler ssession error:", err)
				// Mark driver as disconnected, so the following operation will be ignored.
				driver.connected = false

				// close the connection before reconnected.
				session.close()

				// backoff
				time.Sleep(2 * time.Second)

				// reconnect
				session = newSession(driver, driver.detector)
				driver.session = session
			}
		case <-driver.stopped:
			return nil
		}
	}
}

func (driver *MesosSchedulerDriver) send(call *sched.Call) error {
	msg, err := proto.Marshal(call)
	if err != nil {
		return err
	}

	return driver.session.send(msg)
}

func (driver *MesosSchedulerDriver) LaunchTasks(offerIds []*mesos.OfferID, taskInfos []*mesos.TaskInfo, filters *mesos.Filters) error {
	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &sched.Call{
		FrameworkId: driver.framework.GetId(),
		Type:        sched.Call_ACCEPT.Enum(),
		Accept: &sched.Call_Accept{
			OfferIds: offerIds,
			Operations: []*mesos.Offer_Operation{
				&mesos.Offer_Operation{
					Type: mesos.Offer_Operation_LAUNCH.Enum(),
					Launch: &mesos.Offer_Operation_Launch{
						TaskInfos: taskInfos,
					},
				},
			},
			Filters: filters,
		},
	}

	return driver.send(msg)
}

func (driver *MesosSchedulerDriver) KillTask(taskId, agentId string) error {
	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &sched.Call{
		FrameworkId: driver.framework.GetId(),
		Type:        sched.Call_KILL.Enum(),
		Kill: &sched.Call_Kill{
			TaskId: &mesos.TaskID{
				Value: proto.String(taskId),
			},
			AgentId: &mesos.AgentID{
				Value: proto.String(agentId),
			},
		},
	}

	return driver.send(msg)
}

func (driver *MesosSchedulerDriver) DeclineOffer(offerId *mesos.OfferID, filters *mesos.Filters) error {
	log.Println("Mesos scheduler driver decline offer", offerId.GetValue())

	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &sched.Call{
		FrameworkId: driver.framework.GetId(),
		Type:        sched.Call_DECLINE.Enum(),
		Decline: &sched.Call_Decline{
			OfferIds: []*mesos.OfferID{offerId},
			Filters:  filters,
		},
	}

	fmt.Println(msg)

	return driver.send(msg)
}

func (driver *MesosSchedulerDriver) ReviveOffers() error {
	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &sched.Call{
		FrameworkId: driver.framework.GetId(),
		Type:        sched.Call_REVIVE.Enum(),
		Revive:      &sched.Call_Revive{},
	}

	return driver.send(msg)
}

func (driver *MesosSchedulerDriver) ReconcileTasks() error {
	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &sched.Call{
		FrameworkId: driver.framework.GetId(),
		Type:        sched.Call_RECONCILE.Enum(),
		Reconcile:   &sched.Call_Reconcile{},
	}

	return driver.send(msg)
}

func (driver *MesosSchedulerDriver) Acknowledge(status *mesos.TaskStatus) error {
	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &sched.Call{
		FrameworkId: driver.framework.GetId(),
		Type:        sched.Call_ACKNOWLEDGE.Enum(),
		Acknowledge: &sched.Call_Acknowledge{
			AgentId: status.GetAgentId(),
			TaskId:  status.GetTaskId(),
			Uuid:    status.GetUuid(),
		},
	}

	return driver.send(msg)
}
