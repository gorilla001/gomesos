package scheduler

import (
	"github.com/gogo/protobuf/proto"
	"github.com/pwzgorilla/libmesos"
)

type DriverConfig struct {
	Scheduler libmesos.Scheduler
	Framework *mesos.FrameworkInfo
	Master    string
}

type MesosSchedulerDriver struct {
	sync.Mutex

	framework *mesos.FrameworkInfo
	scheduler libmesos.Scheduler
	connected bool
	started   chan struct{}
	stopped   chan struct{}
}

func NewMesosSchedulerDriver(config DriverConfig) (driver *MesosSchedulerDriver, err error) {
	driver := &MesosSchedulerDriver{
		framework: config.Framework,
		started:   make(chan struct{}),
		stopped:   make(chan struct{}),
	}

	driver.scheduler = config.Scheduler

	driver.init()

	return driver, nil
}

func (driver *MesosSchedulerDriver) init() {
	driver.handlers[mesos.Event_SUBSCRIBED] = driver.frameworkRegistered
	driver.handlers[mesos.Event_OFFERS] = driver.resourcesOffered
	driver.handlers[mesos.Event_RESCIND] = driver.resourceOfferRescinded
	driver.handlers[mesos.Event_UPDATE] = driver.statusUpdated
	driver.handlers[mesos.Event_HEARTBEAT] = driver.heartBeat
	driver.handlers[mesos.Event_ERROR] = driver.frameworkErrorRcvd
	driver.handlers[mesos.Event_FAILURE] = driver.frameworkFailure
	driver.handlers[mesos.Event_MESSAGE] = driver.frameworkMessageRcvd
}

// Connected returns true if the driver has a registered (and authenticated, if enabled)
// connection to the leading mesos master
func (driver *MesosSchedulerDriver) Connected() bool {
	driver.RLock()
	defer driver.RUnlock()

	return driver.connected
}

func (driver *MesosSchedulerDriver) frameworkRegistered(event *mesos.Event) {
	log.Println("Handling scheduler driver framework registered event.")

	if !driver.connected {
		log.Infoln("Ignoring FrameworkRegisteredMessage, the driver is not connected!")
		return
	}

	masterInfo := event.GetMasterInfo()
	masterPid := masterInfo.GetPid()
	frameworkId := event.GetFrameworkId()

	log.Infof("Framework registered with ID=%s\n", frameworkId.GetValue())

	driver.frameworkInfo.Id = frameworkId // generated by master.
	driver.connected = true

	driver.scheduler.Registered(driver, frameworkId, masterInfo)
}

func (driver *MesosSchedulerDriver) resourcesOffered(event *mesos.Event) {
	log.Println("Handling resource offers.")

	if !driver.connected {
		log.Infoln("Ignoring ResourceOffersMessage, the driver is not connected!")
		return
	}

	driver.scheduler.ResourceOffers(driver, event.GetOffers())
}

func (driver *MesosSchedulerDriver) resourceOfferRescinded(event *mesos.Event) {
	log.Println("Handling resource offer rescinded.")

	if !driver.connected {
		log.Infoln("Ignoring ResourceOffersMessage, the driver is not connected!")
		return
	}

	log.Println("Rescinding offer ", event.OfferId.GetValue())

	driver.scheduler.OfferRescinded(driver, event.OfferId)
}

func (driver *MesosSchedulerDriver) statusUpdated(event *mesos.Event) {
	if !driver.connected {
		log.Println("Ignoring StatusUpdate message, the driver is not connected!")
		return
	}

	status := event.GetStatus()

	driver.scheduler.StatusUpdate(driver, status)
}

func (driver *MesosSchedulerDriver) heartbeatReceived(event *mesos.Event) {
	if !driver.connected {
		log.Println("Ignoring HeartBeat message, the driver is not connected!")
		return
	}

	driver.scheduler.HeartBeated()
}

// Starts the scheduler driver.
// Returns immediately if an error occurs within start sequence.
func (driver *MesosSchedulerDriver) Start() error {
	driver.Lock()
	defer driver.Unlock()

	return driver.start()
}

// start expected to be guarded by eventLock
func (driver *MesosSchedulerDriver) start() error {
	select {
	case <-driver.started:
		return errors.New("Unable to Start: driver has already been started once.")
	default: // proceed
	}

	log.Println("Starting the scheduler driver...")

	if driver.connected {
		return errors.New("driver has already connected")
	}

	msg := &mesosproto.Call{
		Type: mesosproto.Call_SUBSCRIBE.Enum(),
		Subscribe: &mesosproto.Call_Subscribe{
			FrameworkInfo: s.framework,
		},
	}

	if driver.frameworkInfo.Id != nil {
		msg.FrameworkId = driver.frameworkInfo.GetId()
	}

	if err := driver.session.start(); err != nil {
		return err
	}

	close(driver.started)

	log.Println("Mesos scheduler driver started")

	return nil
}

func (driver *MesosSchedulerDriver) Stop() {
	log.Println("Stop the scheduler driver")

	close(driver.stopped)
}

func (driver *MesosSchedulerDriver) start() error {
	select {
	case <-driver.started:
		return errors.New("Unable to Start: driver has already been started once.")
	default: // proceed
	}

	log.Println("Starting the scheduler driver...")

	if driver.connected {
		return errors.New("driver has already connected")
	}

	detector, err := detector.NewDetector(driver.master)
	if err != nil {
		return err
	}

	session := newSession(driver, detector)
	driver.session = session
	defer session.close()

	for {
		select {
		case event := <-session.events:
			handler, ok := driver.handlers[event.GetType()]
			if !ok {
				continue
			}

			hanlder(event)
		case err := <-session.errs:
			if err != nil {
				// Mark driver as disconnected, so the following operation will be ignored.
				driver.connected = false

				// close the connection before reconnected.
				session.close()

				session = newSession(driver, detector)
				driver.session = session
			}
		case <-driver.stopped:
			return
		}
	}
}

func (driver *MesosSchedulerDriver) send(call *mesos.Call) error {
	msg, err := proto.Marshal(call)
	if err != nil {
		return err
	}

	return driver.session.send(msg)
}

func (driver *MesosSchedulerDriver) LaunchTasks(offerIds []*mesos.OfferID, taskInfos []*mesos.TaskInfo, filters *mesos.Filters) error {
	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &mesos.Call{
		FrameworkId: driver.frameworkinfo.GetId(),
		Type:        mesos.Call_ACCEPT.Enum(),
		Accept: &mesos.Call_Accept{
			OfferIds: offerIds,
			Operations: []*mesos.Offer_Operation{
				&mesos.Offer_Operation{
					Type: mesos.Offer_Operation_LAUNCH.Enum(),
					Launch: &mesos.Offer_Operation_Launch{
						TaskInfos: taskInfos,
					},
				},
			},
			Filters: filters,
		},
	}

	return driver.send(msg)
}

func (driver *MesosSchedulerDriver) KillTask(taskId, agentId string) error {
	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &mesos.Call{
		FrameworkId: driver.frameworkInfo.GetId(),
		Type:        mesos.Call_KILL.Enum(),
		Kill: &mesos.Call_Kill{
			TaskId: &mesos.TaskID{
				Value: proto.String(taskId),
			},
			AgentId: &mesos.AgentID{
				Value: proto.String(agentId),
			},
		},
	}

	return driver.send(msg)
}

func (driver *MesosSchedulerDriver) DeclineOffer(offerId *mesos.OfferID, filters *mesos.Filters) error {
	driver.Lock()
	defer driver.Unlock()

	if !dirver.connected {
		return ErrDisconnected
	}

	msg := &mesos.Call{
		FrameworkId: driver.frameworkInfo.GetId(),
		Type:        mesos.Call_DECLINE.Enum(),
		Decline: &mesos.Call_Decline{
			OfferIds: []*mesos.OfferID{offerId},
			Filters:  filters,
		},
	}

	return driver.send(msg)
}

func (driver *MesosSchedulerDriver) ReviveOffers() error {
	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &mesos.Call{
		FrameworkId: driver.framework.GetId(),
		Type:        mesos.Call_REVIVE_Enum(),
		Revive:      &mesos.Call_Revive{},
	}

	return driver.send(msg)
}

func (driver *MesosSchedulerDriver) ReconcileTasks() error {
	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &mesos.Call{
		FrameworkId: driver.framework.GetId(),
		Type:        mesos.Call_RECONCILE.Enum(),
		Reconcile:   &mesos.Call_Reconcile{},
	}

	return driver.send(msg)
}

func (driver *MesosSchedulerDriver) Acknowledge(status *mesos.TaskStatus) error {
	driver.Lock()
	defer driver.Unlock()

	if !driver.connected {
		return ErrDisconnected
	}

	msg := &mesos.Call{
		FrameworkId: driver.framework.GetId(),
		Type: mesos.Call_ACKNOWLEDGE.Enum(),
		Acknowledge: &mesos.Call_Acknowledge{
			AgentId: status.GetAgentId(),
			TaskId: status.GetTaskId(),
			Uuid: status.GetUuid(),
		}
	}

	return driver.send(msg)
}
