package scheduler

import (
	"github.com/gogo/protobuf/proto"
)

type DriverConfig struct {
	Scheduler Scheduler
	Framework *mesos.FrameworkInfo
	Master    string
}

type MesosSchedulerDriver struct {
	sync.RWMutex

	frameworkInfo *mesos.FrameworkInfo
	detector      detector.Detector // mesos leader detector
	status        mesos.Status
	connected     bool
	scheduler     Scheduler
	started       chan struct{}
	stopped       chan struct{}
}

func NewMesosSchedulerDriver(config DriverConfig) (driver *MesosSchedulerDriver, err error) {
	driver := &MesosSchedulerDriver{
		framework: config.Framework,
		status:    mesos.Status_DRIVER_NOT_STARTED,
		started:   make(chan struct{}),
		stopped:   make(chan struct{}),
	}

	if err := driver.init(); err != nil {
		return nil, err
	}

	return driver, nil
}

// Status returns the current driver status
func (driver *MesosSchedulerDriver) Status() mesos.Status {
	driver.RLock()
	defer driver.RUnlock()

	return driver.status
}

// Running returns true if the driver is in the DRIVER_RUNNING state
func (driver *MesosSchedulerDriver) Running() bool {
	driver.RLock()
	defer driver.RUnlock()

	return driver.status == mesos.Status_DRIVER_RUNNING
}

// Connected returns true if the driver has a registered (and authenticated, if enabled)
// connection to the leading mesos master
func (driver *MesosSchedulerDriver) Connected() bool {
	driver.RLock()
	defer driver.RUnlock()

	return driver.connected
}

// stopped returns true if the driver status != DRIVER_RUNNING; expects to be guarded by eventLock
func (driver *MesosSchedulerDriver) stopped() bool {
	driver.RLock()
	defer driver.RUnlock()

	return driver.status != mesos.Status_DRIVER_RUNNING
}

// ---------------------- Handlers for Events from Master --------------- //
func (driver *MesosSchedulerDriver) frameworkRegistered(event *mesos.Event) {
	log.Println("Handling scheduler driver framework registered event.")

	masterInfo := event.GetMasterInfo()
	masterPid := masterInfo.GetPid()
	frameworkId := event.GetFrameworkId()

	if driver.status == mesos.Status_DRIVER_ABORTED {
		log.Infof("ignoring FrameworkRegisteredMessage from master %s, driver is aborted", masterPid)
		return
	}

	if driver.connected {
		log.Infoln("ignoring FrameworkRegisteredMessage from master, driver is already connected", masterPid)
		return
	}

	if driver.stopped() {
		log.Infof("ignoring FrameworkRegisteredMessage from master %s, driver is stopped", masterPid)
		return
	}

	log.Infof("Framework registered with ID=%s\n", frameworkId.GetValue())

	driver.frameworkInfo.Id = frameworkId // generated by master.

	driver.connected = true

	driver.scheduler.Registered(driver, frameworkId, masterInfo)
}

func (driver *MesosSchedulerDriver) resourcesOffered(event *mesos.Event) {
	log.Println("Handling resource offers.")

	if driver.status == mesos.Status_DRIVER_ABORTED {
		log.Infoln("Ignoring ResourceOffersMessage, the driver is aborted!")
		return
	}

	if !driver.connected {
		log.Infoln("Ignoring ResourceOffersMessage, the driver is not connected!")
		return
	}

	driver.scheduler.ResourceOffers(driver, event.GetOffers())
}

func (driver *MesosSchedulerDriver) resourceOfferRescinded(event *mesos.Event) {
	log.Println("Handling resource offer rescinded.")

	if driver.status == mesos.Status_DRIVER_ABORTED {
		log.Infoln("Ignoring RescindResourceOfferMessage, the driver is aborted!")
		return
	}

	if !driver.connected {
		log.Infoln("Ignoring ResourceOffersMessage, the driver is not connected!")
		return
	}

	log.Println("Rescinding offer ", event.OfferId.GetValue())
	driver.scheduler.OfferRescinded(driver, event.OfferId)
}

func (driver *MesosSchedulerDriver) statusUpdated(event *mesos.Event) {
	if driver.status != mesos.Status_DRIVER_RUNNING {
		log.Println("Ignoring StatusUpdate message, the driver is not running!")
		return
	}

	if !driver.connected {
		log.Println("Ignoring StatusUpdate message, the driver is not connected!")
		return
	}

	log.Println("Received status update")

	status := event.GetStatus()

	driver.scheduler.StatusUpdate(driver, status)
}

// Starts the scheduler driver.
// Returns immediately if an error occurs within start sequence.
func (driver *MesosSchedulerDriver) Start() (mesos.Status, error) {
	driver.Lock()
	defer driver.Unlock()

	return driver.start()
}

// start expected to be guarded by eventLock
func (driver *MesosSchedulerDriver) start() (mesos.Status, error) {
	select {
	case <-driver.started:
		return driver.status, errors.New("Unable to Start: driver has already been started once.")
	default: // proceed
	}

	log.Println("Starting the scheduler driver...")

	if driver.status != mesos.Status_DRIVER_NOT_STARTED {
		return driver.status, fmt.Errorf("Unable to Start, expecting driver status %s, but is %s:", mesos.Status_DRIVER_NOT_STARTED, driver.status)
	}

	msg := &mesosproto.Call{
		Type: mesosproto.Call_SUBSCRIBE.Enum(),
		Subscribe: &mesosproto.Call_Subscribe{
			FrameworkInfo: s.framework,
		},
	}

	if driver.frameworkInfo.Id != nil {
		msg.FrameworkId = driver.frameworkInfo.GetId()
	}

	if err := driver.session.register(msg); err != nil {
		return driver.status, err
	}

	driver.status = mesos.Status_DRIVER_RUNNING
	close(driver.started)

	log.Println("Mesos scheduler driver started")

	return driver.status, nil
}

func (driver *MesosSchedulerDriver) Stop() {

}
